package de.afrouper.cve;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

public class CVEMavenScanner {

    static final Map<String, CVE_Bundle> CVE_BUNDLE_MAP;
    static {
        CVE_BUNDLE_MAP = new HashMap<>();
        initCVEBundles();
    }

    public static void main(String[] args) throws IOException {
        if (args == null || args.length <= 2) {
            usage();
            return;
        }
        CommandLineParser cli = new CommandLineParser(args);
        String cve = cli.getCve().toUpperCase();
        File path = new File(cli.getPath());

        CVE_Bundle cveBundle = CVE_BUNDLE_MAP.get(cve);
        if(cveBundle == null) {
            System.err.println("You have to specify a valid CVE number; Valid CVEs are: " + validCVEs());
            System.err.println("You gave " + cve);
            return;
        }

        System.out.println("Scan for " + cve);
        MavenDependencyScanner scanner = new MavenDependencyScanner(path, cveBundle.getFixedVersion(), cveBundle.getClazzToCheck());
        scanner.scan();
        Map<String, ScanResult> findings = scanner.getFindings();

        int exitCode = 0;
        System.out.println("Findings: " + findings.size());

        for (Map.Entry<String, ScanResult> entry : findings.entrySet()) {
            ScanResult scanResult = entry.getValue();
            String key = entry.getKey();

            if(scanResult.isVulnerable().isPresent()) {
                if(scanResult.isVulnerable().get()) {
                    System.out.println("[*] \uD83D\uDD25 " + scanResult.getMavenCoordinates() + " in " + key);
                    exitCode++;
                }
                else {
                    System.out.println("[-] ✅ " + scanResult.getMavenCoordinates() + " in " + key);
                }
            }
            else if(scanResult.isPotentiallyVulnerable()) {
                System.out.println("[?] ❓ " + scanResult.getMavenCoordinates() + " in " + key);
                exitCode++;
            }
        }

        System.exit(exitCode);
    }

    private static void initCVEBundles() {
        CVE_BUNDLE_MAP.put("CVE-2022-42889", new CVE_Bundle(
                new MavenCoordinates("org.apache.commons", "commons-text", new ComparableVersion("1.10")),
                "org/apache/commons/text/StringSubstitutor.class"));

        CVE_Bundle log4Shell = new CVE_Bundle(new MavenCoordinates("org.apache.logging.log4j", "log4j-core", new ComparableVersion("2.17.1")),
                "log4j/core/lookup/JndiLookup.class");

        CVE_BUNDLE_MAP.put("CVE-2021-44228", log4Shell);
        CVE_BUNDLE_MAP.put("CVE-2021-45046", log4Shell);
        CVE_BUNDLE_MAP.put("CVE-2021-45105", log4Shell);
    }

    private static void usage() {
        System.out.println("###### Usage ######");
        System.out.println();

        System.out.println("You have to specify a directory and a CVE; e.g.");
        System.out.println("\t[-cve CVE-2021-44228] [<pathToScan>]");
        System.out.println();

        System.out.println("Available CVEs:");
        System.out.println(validCVEs());
        System.out.println();

        System.out.println("###### Usage ######");
    }

    private static String validCVEs() {
        return CVE_BUNDLE_MAP.keySet().stream().collect(Collectors.toList()).toString();
    }
}
